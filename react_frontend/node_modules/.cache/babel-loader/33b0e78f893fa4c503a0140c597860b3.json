{"ast":null,"code":"/*!\n * chartjs-plugin-datasource v0.1.0\n * https://nagix.github.io/chartjs-plugin-datasource\n * (c) 2019 Akihiko Kusanagi\n * Released under the MIT license\n */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('chart.js'), require('xlsx')) : typeof define === 'function' && define.amd ? define(['chart.js', 'xlsx'], factory) : (global = global || self, global.ChartDataSource = factory(global.Chart, global.XLSX));\n})(this, function (Chart, XLSX) {\n  'use strict';\n\n  Chart = Chart && Chart.hasOwnProperty('default') ? Chart['default'] : Chart;\n  XLSX = XLSX && XLSX.hasOwnProperty('default') ? XLSX['default'] : XLSX;\n  var helpers = Chart.helpers; // Base class for all data source (csv, json, etc)\n\n  var DataSource = function DataSource(chart, options) {\n    this.initialize(chart, options);\n  };\n\n  helpers.extend(DataSource.prototype, {\n    _defaultConfig: {},\n    _responseType: null,\n    initialize: function initialize(chart, options) {\n      var me = this;\n      me._chart = chart;\n      me._options = helpers.extend({}, me._defaultConfig, options);\n    },\n    request: function request(callback) {\n      var me = this;\n      var url = me.getUrl();\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', url);\n      xhr.responseType = me._responseType;\n\n      xhr.onreadystatechange = function () {\n        var data;\n\n        if (xhr.readyState === 4) {\n          if (xhr.status === 200) {\n            data = me.convert(xhr.response);\n          }\n\n          callback.call(me, {\n            success: xhr.status === 200,\n            data: data\n          });\n        }\n      };\n\n      xhr.send();\n    },\n    convert: function convert() {// noop\n    },\n    getType: function getType() {\n      return this._options.type;\n    },\n    getUrl: function getUrl() {\n      return this._options.url;\n    }\n  });\n  DataSource.extend = helpers.inherits;\n  var helpers$1 = Chart.helpers;\n  var datasourceHelpers = {\n    // For Chart.js 2.6.0 backward compatibility\n    isObject: helpers$1.isObject || function (value) {\n      return value !== null && Object.prototype.toString.call(value) === '[object Object]';\n    },\n    // For Chart.js 2.6.0 backward compatibility\n    valueOrDefault: helpers$1.valueOrDefault || helpers$1.getValueOrDefault,\n    getExtension: function getExtension(url) {\n      var matches = url.match(/\\.([0-9a-z]+)(?:[?#]|$)/i);\n\n      if (matches) {\n        return matches[1];\n      }\n    },\n    transpose: function transpose(arrays) {\n      var columns = arrays[0].length;\n      var rows = arrays.length;\n      var result = [];\n      var i, j, array;\n\n      for (i = 0; i < columns; ++i) {\n        array = [];\n\n        for (j = 0; j < rows; ++j) {\n          array.push(arrays[j][i]);\n        }\n\n        result.push(array);\n      }\n\n      return result;\n    },\n    dedup: function dedup(array) {\n      return array.filter(function (value, i) {\n        return array.indexOf(value) === i;\n      });\n    }\n  };\n  var helpers$2 = Chart.helpers;\n\n  function getDelimiter(url) {\n    switch (datasourceHelpers.getExtension(url)) {\n      default:\n        return ',';\n\n      case 'tsv':\n        return '\\t';\n\n      case 'psv':\n        return '|';\n    }\n  }\n\n  function csvToArrays(str, delimiter) {\n    var regex = new RegExp('(' + delimiter + '|\\r?\\n(?!$)|\\r(?!$)|^(?!$))(?:\"((?:\\\\.|\"\"|[^\\\\\"])*)\"|([^' + delimiter + '\"\\r\\n]*))', 'gi');\n    var array = [];\n    var arrays = [array];\n    var max = 0;\n    var matches, i, ilen, j;\n\n    while (matches = regex.exec(str)) {\n      if (matches[1]) {\n        if (matches[1] !== delimiter) {\n          array = [];\n          arrays.push(array);\n        } else if (arrays.length === 1 && array.length === 0) {\n          array.push(undefined);\n        }\n      }\n\n      array.push(matches[2] !== undefined ? matches[2].replace(/[\\\\\"](.)/g, '$1') : matches[3] ? matches[3] : undefined);\n      max = Math.max(max, array.length);\n    }\n\n    for (i = 0, ilen = arrays.length; i < ilen; ++i) {\n      array = arrays[i];\n\n      for (j = array.length; j < max; ++j) {\n        array.push(undefined);\n      }\n    }\n\n    return arrays;\n  }\n\n  function getRowHeader(arrays) {\n    var array = arrays.shift() || [];\n    return array.map(function (value) {\n      return datasourceHelpers.valueOrDefault(value, '');\n    });\n  }\n\n  function getColumnHeader(arrays) {\n    return arrays.map(function (array) {\n      return datasourceHelpers.valueOrDefault(array.shift(), '');\n    });\n  }\n\n  function getIndex(value, array) {\n    if (helpers$2.isFinite(value) && value >= 0 && Math.floor(value) === value) {\n      return value;\n    }\n\n    return array.indexOf(value);\n  }\n\n  function getLabels(arrays, value, datapointLabels) {\n    var index = getIndex(value, datapointLabels);\n    var result = [];\n    var i, ilen;\n\n    for (i = 0, ilen = arrays.length; i < ilen; ++i) {\n      result.push(arrays[i][index]);\n    }\n\n    return datasourceHelpers.dedup(result);\n  }\n\n  function convertDatapointLabels(labels, mapping) {\n    var keys = Object.keys(mapping);\n    var result = labels.slice();\n    var key, index, i, ilen;\n\n    for (i = 0, ilen = keys.length; i < ilen; ++i) {\n      key = keys[i];\n      index = getIndex(mapping[key], labels);\n\n      if (index !== -1 && key !== '_index') {\n        result[index] = key;\n      }\n    }\n\n    return result;\n  }\n\n  function getPointData(arrays, datasetLabels, datapointLabels) {\n    var lookup = {};\n    var result = [];\n    var array, obj, datapointLabel, datapointValue, i, j, ilen, jlen;\n\n    for (i = 0, ilen = datasetLabels.length; i < ilen; ++i) {\n      lookup[datasetLabels[i]] = i;\n      result[i] = [];\n    }\n\n    for (i = 0, ilen = arrays.length; i < ilen; ++i) {\n      array = arrays[i];\n      obj = {};\n\n      for (j = 0, jlen = array.length; j < jlen; ++j) {\n        datapointLabel = datapointLabels[j];\n        datapointValue = array[j];\n\n        if (datapointLabel === '_dataset') {\n          result[lookup[datapointValue]].push(obj);\n        } else {\n          obj[datapointLabel] = datapointValue;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  var CsvDataSource = DataSource.extend({\n    _defaultConfig: {\n      type: 'csv',\n      rowMapping: 'dataset',\n      datasetLabels: true,\n      indexLabels: true,\n      datapointLabels: true,\n      datapointLabelMapping: {\n        _dataset: '_dataset',\n        _index: 'x'\n      }\n    },\n    _responseType: 'text',\n    initialize: function initialize() {\n      var me = this;\n      var options;\n      DataSource.prototype.initialize.apply(me, arguments);\n      options = me._options;\n\n      if (options.delimiter === undefined) {\n        options.delimiter = getDelimiter(options.url);\n      }\n    },\n    convert: function convert(input) {\n      var me = this;\n      var options = me._options;\n      var arrays = csvToArrays(input, options.delimiter);\n      var datasets = [];\n      var datapointLabels, datasetLabels, indexLabels, data, i, ilen;\n\n      switch (options.rowMapping) {\n        default:\n          if (options.indexLabels === true) {\n            indexLabels = getRowHeader(arrays);\n          }\n\n          if (options.datasetLabels === true) {\n            if (indexLabels) {\n              indexLabels.shift();\n            }\n\n            datasetLabels = getColumnHeader(arrays);\n          }\n\n          data = arrays;\n          break;\n\n        case 'index':\n          if (options.datasetLabels === true) {\n            datasetLabels = getRowHeader(arrays);\n          }\n\n          if (options.indexLabels === true) {\n            if (datasetLabels) {\n              datasetLabels.shift();\n            }\n\n            indexLabels = getColumnHeader(arrays);\n          }\n\n          data = datasourceHelpers.transpose(arrays);\n          break;\n\n        case 'datapoint':\n          if (options.datapointLabels === true) {\n            datapointLabels = getRowHeader(arrays);\n          }\n\n          if (datapointLabels === undefined) {\n            datapointLabels = ['_dataset', 'x', 'y', 'r'];\n          }\n\n          datasetLabels = getLabels(arrays, options.datapointLabelMapping._dataset, datapointLabels);\n          indexLabels = getLabels(arrays, options.datapointLabelMapping._index, datapointLabels);\n          datapointLabels = convertDatapointLabels(datapointLabels, options.datapointLabelMapping);\n          data = getPointData(arrays, datasetLabels, datapointLabels);\n          break;\n      }\n\n      datasetLabels = datasetLabels || [];\n\n      for (i = 0, ilen = data.length; i < ilen; ++i) {\n        datasets.push({\n          label: datasetLabels[i],\n          data: data[i]\n        });\n      }\n\n      return {\n        labels: indexLabels,\n        datasets: datasets\n      };\n    }\n  });\n  CsvDataSource._extensions = ['csv', 'tsv', 'psv'];\n  var helpers$3 = Chart.helpers;\n\n  function query(obj, expr) {\n    var regex = /(?:,|^)\\s*(?:\"([^\"]*)\"|'([^']*)'|([^,\\s]*))/gi;\n    var result = [];\n    var matches, bracketKey, dotKey, nextExprWithDot, nextExpr, quotedKey, subset, i, ilen, keys;\n\n    if (obj === undefined || expr === undefined) {\n      return obj;\n    } // Allow up to two levels of [] nesting\n\n\n    matches = expr.match(/(?:\\[((?:\\[[^\\]]*\\]|[^\\]])*)\\]|([^.[]*))(\\.?(.*))/);\n\n    if (!matches) {\n      return;\n    }\n\n    bracketKey = matches[1];\n    dotKey = matches[2];\n    nextExprWithDot = matches[3];\n    nextExpr = nextExprWithDot ? matches[4] : undefined; // If the wildcard is used, return an array\n\n    if (dotKey === '*' || bracketKey === '*') {\n      if (helpers$3.isArray(obj)) {\n        for (i = 0, ilen = obj.length; i < ilen; ++i) {\n          result.push(query(obj[i], nextExpr));\n        }\n      } else if (datasourceHelpers.isObject(obj)) {\n        keys = result._labels = Object.keys(obj);\n\n        for (i = 0, ilen = keys.length; i < ilen; ++i) {\n          result.push(query(obj[keys[i]], nextExpr));\n        }\n      }\n\n      return result;\n    } // If the dot notation is used, return a single value\n\n\n    if (dotKey !== undefined) {\n      return query(obj[dotKey], nextExpr);\n    } // If the bracket notation is used, process the list and return an array or a single value\n\n\n    keys = result._labels = [];\n\n    while (matches = regex.exec(bracketKey)) {\n      quotedKey = datasourceHelpers.valueOrDefault(matches[1], matches[2]);\n\n      if (quotedKey !== undefined) {\n        subset = query(obj[quotedKey], nextExpr);\n      } else {\n        subset = query(obj, matches[3] + nextExprWithDot);\n      }\n\n      result.push(subset);\n      keys.push(datasourceHelpers.valueOrDefault(quotedKey, matches[3]));\n    }\n\n    return result.length > 1 ? result : result[0];\n  }\n\n  function getSecondLevelLabels(data) {\n    var dataLen = data.length;\n    var array = [];\n    var newArray, labels, labelLen, i, j;\n\n    for (i = 0; i < dataLen; ++i) {\n      Array.prototype.push.apply(array, data[i]._labels);\n    }\n\n    labels = datasourceHelpers.dedup(array);\n    labelLen = labels.length;\n\n    for (i = 0; i < dataLen; ++i) {\n      array = data[i];\n      newArray = [];\n\n      for (j = 0; j < labelLen; ++j) {\n        newArray.push(array[array._labels.indexOf(labels[j])]);\n      }\n\n      data[i] = newArray;\n    }\n\n    return labels;\n  }\n\n  function getLabels$1(arrays, value) {\n    var result = [];\n    var array, labels, i, ilen;\n\n    for (i = 0, ilen = arrays.length; i < ilen; ++i) {\n      array = arrays[i];\n      labels = array._labels;\n      result.push(arrays[i][labels ? labels.indexOf(value) : value]);\n    }\n\n    return datasourceHelpers.dedup(result);\n  }\n\n  function getPointData$1(arrays, datasetLabels, datapointLabelMapping) {\n    var keys = Object.keys(datapointLabelMapping);\n    var datapointLabelLookup = {};\n    var datasetLabelLookup = {};\n    var result = [];\n    var array, labels, obj, key, datapointLabel, datapointValue, i, j, ilen, jlen;\n\n    for (i = 0, ilen = keys.length; i < ilen; ++i) {\n      key = keys[i];\n\n      if (key !== '_index') {\n        datapointLabelLookup[datapointLabelMapping[key]] = key;\n      }\n    }\n\n    for (i = 0, ilen = datasetLabels.length; i < ilen; ++i) {\n      datasetLabelLookup[datasetLabels[i]] = i;\n      result[i] = [];\n    }\n\n    for (i = 0, ilen = arrays.length; i < ilen; ++i) {\n      array = arrays[i];\n      labels = array._labels;\n      obj = {};\n\n      for (j = 0, jlen = array.length; j < jlen; ++j) {\n        key = labels ? labels[j] : j;\n        datapointLabel = datasourceHelpers.valueOrDefault(datapointLabelLookup[key], key);\n        datapointValue = array[j];\n\n        if (datapointLabel === '_dataset') {\n          result[datasetLabelLookup[datapointValue]].push(obj);\n        } else {\n          obj[datapointLabel] = datapointValue;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  var JsonDataSource = DataSource.extend({\n    _defaultConfig: {\n      type: 'json',\n      rowMapping: 'dataset',\n      datapointLabelMapping: {\n        _dataset: '_dataset',\n        _index: 'x'\n      }\n    },\n    _responseType: 'json',\n    convert: function convert(input) {\n      var me = this;\n      var options = me._options;\n      var datasets = [];\n      var datasetLabels, indexLabels, data, arrays, i, ilen;\n\n      if (options.data) {\n        arrays = query(input, options.data);\n      }\n\n      switch (options.rowMapping) {\n        default:\n          if (options.datasetLabels) {\n            datasetLabels = query(input, options.datasetLabels);\n          } else if (arrays) {\n            datasetLabels = arrays._labels;\n          }\n\n          if (options.indexLabels) {\n            indexLabels = query(input, options.indexLabels);\n          } else if (arrays) {\n            indexLabels = getSecondLevelLabels(arrays);\n          }\n\n          data = arrays;\n          break;\n\n        case 'index':\n          if (options.datasetLabels) {\n            datasetLabels = query(input, options.datasetLabels);\n          } else if (arrays) {\n            datasetLabels = getSecondLevelLabels(arrays);\n          }\n\n          if (options.indexLabels) {\n            indexLabels = query(input, options.indexLabels);\n          } else if (arrays) {\n            indexLabels = arrays._labels;\n          }\n\n          if (arrays) {\n            data = datasourceHelpers.transpose(arrays);\n          }\n\n          break;\n\n        case 'datapoint':\n          if (arrays) {\n            datasetLabels = getLabels$1(arrays, options.datapointLabelMapping._dataset);\n            indexLabels = getLabels$1(arrays, options.datapointLabelMapping._index);\n            data = getPointData$1(arrays, datasetLabels, options.datapointLabelMapping);\n          }\n\n          break;\n      }\n\n      datasetLabels = datasetLabels || [];\n      data = data || [];\n\n      for (i = 0, ilen = Math.max(datasetLabels.length, data.length); i < ilen; ++i) {\n        datasets.push({\n          label: datasetLabels[i],\n          data: data[i]\n        });\n      }\n\n      return {\n        labels: indexLabels,\n        datasets: datasets\n      };\n    }\n  });\n  JsonDataSource._extensions = ['json'];\n  var JsonLinesDataSource = JsonDataSource.extend({\n    _defaultConfig: {\n      type: 'jsonl',\n      rowMapping: 'index',\n      datapointLabelMapping: {\n        _dataset: '_dataset',\n        _index: 'x'\n      }\n    },\n    _responseType: 'text',\n    convert: function convert(input) {\n      var array = JSON.parse('[' + input.trim().split('\\n').join(',') + ']');\n      return JsonDataSource.prototype.convert.call(this, array);\n    }\n  });\n  JsonLinesDataSource._extensions = ['jsonl'];\n  var helpers$4 = Chart.helpers;\n\n  function parseExpression(workbook, expr) {\n    var matches, sheetName, sheet, rangeExpr, ref, range, refRange;\n\n    while (expr) {\n      if (expr.match(/^(([A-Z]+\\d*|[A-Z]*\\d+):([A-Z]+\\d*|[A-Z]*\\d+)|[A-Z]+\\d+)$/)) {\n        rangeExpr = expr;\n        break;\n      } else if (sheetName) {\n        break;\n      }\n\n      matches = expr.match(/^(?:'([^']*)'|([^!]*))(?:!(.*))?$/);\n      sheetName = datasourceHelpers.valueOrDefault(matches[1], matches[2]);\n      expr = matches[3];\n    }\n\n    sheet = workbook.Sheets[datasourceHelpers.valueOrDefault(sheetName, workbook.SheetNames[0])];\n    ref = sheet ? sheet['!ref'] : '';\n    range = XLSX.utils.decode_range(datasourceHelpers.valueOrDefault(rangeExpr, ref));\n\n    if (ref) {\n      refRange = XLSX.utils.decode_range(ref);\n\n      if (range.s.c === -1) {\n        range.s = {\n          c: refRange.s.c,\n          r: range.s.r\n        };\n      }\n\n      if (range.e.c === -1) {\n        range.e = {\n          c: refRange.e.c,\n          r: range.e.r\n        };\n      }\n\n      if (isNaN(range.s.r)) {\n        range.s = {\n          c: range.s.c,\n          r: refRange.s.r\n        };\n      }\n\n      if (isNaN(range.e.r)) {\n        range.e = {\n          c: range.e.c,\n          r: refRange.e.r\n        };\n      }\n    }\n\n    return {\n      sheet: sheet,\n      range: range,\n      detected: rangeExpr === undefined\n    };\n  }\n\n  function query$1(sheetRange, options) {\n    var sheet = sheetRange.sheet;\n    var range = sheetRange.range;\n    var r = options && options.columnOriented ? 'c' : 'r';\n    var c = options && options.columnOriented ? 'r' : 'c';\n    var results = [];\n    var result, cellExpr, cell, value, i, j, ilen, jlen;\n\n    if (!sheet) {\n      return results;\n    }\n\n    for (i = range.s[r], ilen = range.e[r]; i <= ilen; ++i) {\n      result = [];\n\n      for (j = range.s[c], jlen = range.e[c]; j <= jlen; ++j) {\n        cellExpr = {};\n        cellExpr[r] = i;\n        cellExpr[c] = j;\n        cell = sheet[XLSX.utils.encode_cell(cellExpr)] || {};\n        value = cell.v;\n\n        if (options && options.header) {\n          value = datasourceHelpers.valueOrDefault(value, '');\n        }\n\n        result.push(value);\n      }\n\n      results.push(result.length > 1 ? result : result[0]);\n    }\n\n    return results;\n  }\n\n  function getRowHeader$1(sheetRange) {\n    var range = helpers$4.clone(sheetRange.range);\n\n    if (range.s.r >= range.e.r) {\n      return;\n    }\n\n    range.e.r = range.s.r;\n    sheetRange.range.s.r++;\n    return query$1({\n      sheet: sheetRange.sheet,\n      range: range\n    }, {\n      columnOriented: true,\n      header: true\n    });\n  }\n\n  function getColumnHeader$1(sheetRange) {\n    var range = helpers$4.clone(sheetRange.range);\n\n    if (range.s.c >= range.e.c) {\n      return;\n    }\n\n    range.e.c = range.s.c;\n    sheetRange.range.s.c++;\n    return query$1({\n      sheet: sheetRange.sheet,\n      range: range\n    }, {\n      header: true\n    });\n  }\n\n  function getIndex$1(value, array, offset) {\n    if (value.match(/^[A-Z]+$/)) {\n      return XLSX.utils.decode_col(value) - offset;\n    }\n\n    return array.indexOf(value);\n  }\n\n  function getLables(sheetRange, value, datapointLabels) {\n    var range = helpers$4.clone(sheetRange.range);\n    var index = getIndex$1(value, datapointLabels, range.s.c);\n    range.s.c = range.e.c = index !== -1 ? index + range.s.c : index;\n    return datasourceHelpers.dedup(query$1({\n      sheet: sheetRange.sheet,\n      range: range\n    }, {\n      header: true\n    }));\n  }\n\n  function convertDatapointLabels$1(labels, mapping) {\n    var keys = Object.keys(mapping);\n    var result = labels.slice();\n    var key, index, i, ilen;\n\n    for (i = 0, ilen = keys.length; i < ilen; ++i) {\n      key = keys[i];\n      index = getIndex$1(mapping[key], labels);\n\n      if (index !== -1 && key !== '_index') {\n        result[index] = key;\n      }\n    }\n\n    return result;\n  }\n\n  function getPointData$2(arrays, datasetLabels, datapointLabels) {\n    var lookup = {};\n    var result = [];\n    var array, obj, datapointLabel, datapointValue, i, j, ilen, jlen;\n\n    for (i = 0, ilen = datasetLabels.length; i < ilen; ++i) {\n      lookup[datasetLabels[i]] = i;\n      result[i] = [];\n    }\n\n    for (i = 0, ilen = arrays.length; i < ilen; ++i) {\n      array = arrays[i];\n      obj = {};\n\n      for (j = 0, jlen = array.length; j < jlen; ++j) {\n        datapointLabel = datapointLabels[j];\n        datapointValue = array[j];\n\n        if (datapointLabel === '_dataset') {\n          result[lookup[datapointValue]].push(obj);\n        } else {\n          obj[datapointLabel] = datapointValue;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  var SheetDataSource = DataSource.extend({\n    _defaultConfig: {\n      type: 'sheet',\n      rowMapping: 'dataset',\n      datapointLabelMapping: {\n        _dataset: '_dataset',\n        _index: 'x'\n      }\n    },\n    _responseType: 'arraybuffer',\n    initialize: function initialize() {\n      if (!XLSX) {\n        throw new Error('XLSX is not found. Please load the xlsx library before loading this plugin.');\n      }\n\n      DataSource.prototype.initialize.apply(this, arguments);\n    },\n    convert: function convert(input) {\n      var me = this;\n      var options = me._options;\n      var workbook = XLSX.read(new Uint8Array(input), {\n        type: 'array'\n      });\n      var dataRange = parseExpression(workbook, datasourceHelpers.valueOrDefault(options.data, ''));\n      var detected = dataRange.detected;\n      var datasets = [];\n      var datapointLabels, datasetLabels, indexLabels, data, i, ilen;\n\n      switch (options.rowMapping) {\n        default:\n          if (options.indexLabels) {\n            indexLabels = query$1(parseExpression(workbook, options.indexLabels), {\n              columnOriented: true,\n              header: true\n            });\n          } else if (detected) {\n            indexLabels = getRowHeader$1(dataRange);\n          }\n\n          if (options.datasetLabels) {\n            datasetLabels = query$1(parseExpression(workbook, options.datasetLabels), {\n              header: true\n            });\n          } else if (detected) {\n            if (indexLabels) {\n              indexLabels.shift();\n            }\n\n            datasetLabels = getColumnHeader$1(dataRange);\n          }\n\n          data = query$1(dataRange);\n          break;\n\n        case 'index':\n          if (options.datasetLabels) {\n            datasetLabels = query$1(parseExpression(workbook, options.datasetLabels), {\n              columnOriented: true,\n              header: true\n            });\n          } else if (detected) {\n            datasetLabels = getRowHeader$1(dataRange);\n          }\n\n          if (options.indexLabels) {\n            indexLabels = query$1(parseExpression(workbook, options.indexLabels), {\n              header: true\n            });\n          } else if (detected) {\n            if (datasetLabels) {\n              datasetLabels.shift();\n            }\n\n            indexLabels = getColumnHeader$1(dataRange);\n          }\n\n          data = query$1(dataRange, {\n            columnOriented: true\n          });\n          break;\n\n        case 'datapoint':\n          if (options.datapointLabels) {\n            datapointLabels = query$1(parseExpression(workbook, options.datapointLabels), {\n              columnOriented: true,\n              header: true\n            });\n          } else if (detected) {\n            datapointLabels = getRowHeader$1(dataRange);\n          }\n\n          if (datapointLabels === undefined) {\n            datapointLabels = ['_dataset', 'x', 'y', 'r'];\n          }\n\n          datasetLabels = getLables(dataRange, options.datapointLabelMapping._dataset, datapointLabels);\n          indexLabels = getLables(dataRange, options.datapointLabelMapping._index, datapointLabels);\n          datapointLabels = convertDatapointLabels$1(datapointLabels, options.datapointLabelMapping);\n          data = getPointData$2(query$1(dataRange), datasetLabels, datapointLabels);\n          break;\n      }\n\n      datasetLabels = datasetLabels || [];\n      data = data || [];\n\n      for (i = 0, ilen = Math.max(datasetLabels.length, data.length); i < ilen; ++i) {\n        datasets.push({\n          label: datasetLabels[i],\n          data: data[i]\n        });\n      }\n\n      return {\n        labels: indexLabels,\n        datasets: datasets\n      };\n    }\n  });\n  SheetDataSource._extensions = ['xlsx', 'xlsm', 'xlsb', 'xls', 'xlw', 'xml', 'csv', 'txt', 'dif', 'sylk', 'slk', 'prn', 'ods', 'fods', 'uos', 'dbf', 'wks', 'wk1', 'wk2', 'wk3', 'wk4', '123', 'wq1', 'wq2', 'wb1', 'wb2', 'wb3', 'qpw', 'html', 'htm', 'eth'];\n  var datasources = {\n    csv: CsvDataSource,\n    json: JsonDataSource,\n    jsonl: JsonLinesDataSource,\n    sheet: SheetDataSource\n  };\n  var helpers$5 = Chart.helpers;\n  var EXPANDO_KEY = '$datasource';\n  Chart.defaults.global.plugins.datasource = {};\n\n  function mergeData(target, source) {\n    var sourceDatasets = source.datasets;\n    var targetDatasets = target.datasets;\n    var sourceLabels = source.labels;\n    var targetLabels = target.labels;\n    var max = 0;\n    var sourceDataset, targetDataset, sourceLabel, sourceData, i, ilen;\n\n    if (helpers$5.isArray(sourceDatasets)) {\n      if (!helpers$5.isArray(targetDatasets)) {\n        targetDatasets = target.datasets = [];\n      }\n\n      for (i = 0, ilen = sourceDatasets.length; i < ilen; ++i) {\n        sourceDataset = sourceDatasets[i];\n        targetDataset = targetDatasets[i];\n\n        if (!datasourceHelpers.isObject(targetDataset)) {\n          targetDataset = targetDatasets[i] = {};\n        }\n\n        sourceLabel = sourceDataset.label;\n\n        if (sourceLabel !== undefined) {\n          targetDataset.label = sourceLabel;\n        } else if (targetDataset.label === undefined) {\n          targetDataset.label = 'Dataset ' + (i + 1);\n        }\n\n        sourceData = sourceDataset.data;\n\n        if (helpers$5.isArray(sourceData)) {\n          targetDataset.data = sourceData;\n          max = Math.max(max, sourceData.length);\n        }\n      }\n    }\n\n    if (helpers$5.isArray(sourceLabels)) {\n      target.labels = sourceLabels;\n    } else if (!helpers$5.isArray(targetLabels) || !targetLabels.length) {\n      targetLabels = target.labels = [];\n\n      for (i = 0; i < max; ++i) {\n        targetLabels[i] = '' + (i + 1);\n      }\n    }\n  }\n\n  var DataSourcePlugin = {\n    id: 'datasource',\n    beforeInit: function beforeInit(chart) {\n      chart[EXPANDO_KEY] = {};\n    },\n    beforeUpdate: function beforeUpdate(chart, options) {\n      var me = this;\n      var expando = chart[EXPANDO_KEY];\n      var url = options.url;\n      var type = options.type || me.getType(url);\n      var DataSourceClass = me.getConstructor(type);\n      var datasource = expando._datasource;\n\n      if (url && DataSourceClass && !chart[EXPANDO_KEY]._delayed) {\n        if (!datasource || datasource.getType() !== type || datasource.getUrl() !== url) {\n          datasource = expando._datasource = new DataSourceClass(chart, options);\n        }\n\n        datasource.request(function (response) {\n          mergeData(chart.data, response.data);\n          expando._delayed = true;\n          chart.update();\n          delete expando._delayed;\n        });\n        return false;\n      }\n    },\n    constructors: {},\n    extensions: {},\n    register: function register(type, constructor, extensions) {\n      var me = this;\n      me.constructors[type] = constructor;\n      helpers$5.each(extensions, function (extension) {\n        me.extensions[extension] = type;\n      });\n    },\n    getType: function getType(url) {\n      if (url) {\n        return this.extensions[datasourceHelpers.getExtension(url)] || 'json';\n      }\n    },\n    getConstructor: function getConstructor(type) {\n      if (!this.constructors.hasOwnProperty(type)) {\n        throw new Error('\"' + type + '\" is not a data source type.');\n      }\n\n      return this.constructors[type];\n    }\n  };\n  Chart.helpers.each(datasources, function (datasource, type) {\n    DataSourcePlugin.register(type, datasource, datasource._extensions, datasource._defaults);\n  });\n  return DataSourcePlugin;\n});","map":null,"metadata":{},"sourceType":"script"}